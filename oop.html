<!doctype html>
<html lang="en">
   <head>
      <!-- Required meta tags -->
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
      <!-- Bootstrap CSS -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous"/>
      <link rel="stylesheet" type="text/css" href="index.css"/>
   </head>
   <body data-spy="scroll" data-target=".navbar" data-offset="50">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
         <a class="navbar-brand" href="index.html">Andy's Website</a>
         <ul class="navbar-nav">
            <li class="nav-item">
               <a class="nav-link" href="index.html#home">Home</a>
            </li>
            <li class="nav-item">
               <a class="nav-link " href="index.html#s-about">About Me</a>
            </li>
            <li class="nav-item">
               <a class="nav-link" href="index.html#s-code">Code Portfolio</a>
            </li>
            <li class="nav-item dropdown">
               <a class="nav-link dropdown-toggle" href="programming.html" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
               Past Projects
               </a>
               <div class="dropdown-menu" aria-labelledby="navbarDropdown">
							<a class="dropdown-item" href="programming.html#s-chess">Chess Program</a>
							<a class="dropdown-item" href="programming.html#s-contest">Contest Problem Solutions</a>
							<div class="dropdown-divider"></div>
							<a class="dropdown-item" href="#">In Progress!</a>
						</div>
            </li>
            <li class="nav-item dropdown">
               <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
               Java Explanations
               </a>
               <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item active" href="#">OOP</a>
                  <a class="dropdown-item" href="#">Arrays and Arraylists</a>
                  <div class="dropdown-divider"></div>
                  <a class="dropdown-item" href="#">In Progress!</a>
               </div>
            </li>
         </ul>
      </nav>
      <div class = "container" id = "s-home">
         <p>
            <br></br>
         </p>
         <p>
            <br></br>
         </p>
      </div>
      <div class = "container">
         <div class = "row card bg-dark">
            <div class = "card-body">
               <h1 class = "display-4 text-light card-title">OOP Explanation</h1>
               <hr class="my-4 bg-light"/>
               <div class="row">
                  <div class="col-4 py-0">
                     <div class="list-group list-group-flush shadow-lg" id="list-tab" role="tablist">
                        <button type = "button" class="list-group-item list-group-item-action active bg-dark text-light borderless" id="list-home-list" data-toggle="list" href="#list-0" role="tab" >Introduction to Objects and Classes</button>
                        <button type = "button" class="list-group-item list-group-item-action bg-dark text-light borderless" id="list-profile-list" data-toggle="list" href="#list-1" role="tab" >Methods and Types of Methods</button>
                        <button type = "button" class="list-group-item list-group-item-action bg-dark text-light borderless" id="list-messages-list" data-toggle="list" href="#list-2" role="tab" >Encapsulation</button>
                        <button type = "button" class="list-group-item list-group-item-action bg-dark text-light borderless" id="list-settings-list" data-toggle="list" href="#list-3" role="tab" >Inheritance</button>
						<button type = "button" class="list-group-item list-group-item-action bg-dark text-light borderless" id="list-settings-list" data-toggle="list" href="#list-4" role="tab" >Polymorphism</button>
						<button type = "button" class="list-group-item list-group-item-action bg-dark text-light borderless" id="list-settings-list" data-toggle="list" href="#list-5" role="tab" >Abstraction</button>
                     </div>
                  </div>
                  <div class="col-8 py-0">
                     <div class="tab-content" id="nav-tabContent">
                        <div class="tab-pane fade show active text-light" id="list-0" role="tabpanel">
						<h4 class = "text-light">OOP</h4>
                           OOP, otherwise referred to as Object Oriented Programming, is a system of programming principles that leads to programs are easy to understand, program, and model the real world with. These basic principles are: </br></br>
                           <b>Inheritance</b></br>
                           <b>Encapsulation</b></br>
                           <b>Abstraction</b></br>
                           <b>Polymorphism</b></br></br>
                           OOP contains two major building blocks: classes and objects. A class is, in essence, a blueprint. It has certain modifiable properties, known as fields, and certain actions or functionalities, known as methods. An object is a thing made from that blueprint, with specific values for each field. This grouping of properties and methods into a single bundle is known as encapsulation. Now, an example in code.
                           <pre class = "prettyprint lang-java bg-dark shadow-lg">
							<code>
public class Ball{
	public String color;
	public int size;
	public Ball(String c, int s){
		color = c;
		size = s;
	}
	public void roll(){
		//code not shown
	}
}
							</code>
							</pre>
                           Here’s our very basic class called Ball. We will add more methods and properties later in the explanation.
                           Let’s go through each bit of code. </br>
                           <b>The first line</b> declares the class and gives some basic information like the name of the class and the access level (we will discuss this later in Encapsulation).</br>
                           <b>The next two lines</b> declares the fields, or instance variables. The first word declares the access level. The second word declares the data type of the field (the type of data it stores, like a string or an integer). The last word declares the field’s name. </br>
                           <b>The next 4 lines</b> are known as a constructor, and it allows for an object to be created from the class. It will be discussed later in Methods. </br>
                           <b>The next 3 lines</b> contains methods, and allows the object that the class creates to be interacted with and do things. The different types of methods and what they can do will be discussed later. </br>
                           <p>Now, let&rsquo;s create a ball object.</p>
                           <pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>Ball redBall = new Ball(&ldquo;red&rdquo;, 2);</code></pre>
                           <p> The first part specifies the type of object this variable is. The second part specifies the variable name. The third section creates a Ball object using the specified parameters of the constructor(s).</p>
                           <p>Now we can also use a method on the object we have just created:</p>
                           <pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>redBall.roll();</code></pre>
                           <p>Now that I have discussed the basic features of classes and objects, we can discuss their capabilities in more detail.</p>
                        </div>
                        <div class="tab-pane fade" id="list-1" role="tabpanel">
						<h4 class = "text-light">Methods</h4>
						<p>Methods are a key component of OOP and its usefulness.
There are many types of methods used in OOP, such as the mutators and accessors we have discussed earlier.
In general, all methods have an access level, a return type, and a name. Methods may also be static or non static. 
All methods have either a certain data type or void as a return type. Methods returning a data type will give a value of that type at the end of their execution. Methods returning void may still perform actions but will not return any values at the end of their execution.
</p>
						<h4 class = "text-light">Mutators and Accessors</h4>
<p>Let&rsquo;s say I want to change the color of the ball, from red to blue. Currently, the only way to do that would be to do <code>redBall.color = &ldquo;blue&rdquo;;</code> but that is generally considered bad programming style and would likely not work in most programs due to instance variables having a private access level. A similar problem arises when I want to get what the color of the ball is, as there is no other option but to use redBall.color. Therefore, we use mutators and accessors, otherwise known as &ldquo;getters&rdquo; and &ldquo;setters&rdquo;. They are simply methods which will modify or access the variables in a less direct sense, which allows for more control over the values that are allowed.</p>

<p>The updated code with set and get methods becomes: </p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public class Ball{
	public String color;
	public int size;
	public Ball(String c, int s){
		color = c;
		size = s;
	}
	public String getColor(){
		return color;
	}
	public int getSize(){
		return size;
	}
	public void setColor(String c){
		color = c;
	}
	public void setSize(int s){
		size = s;
	}
	public void roll(){
		//code not shown
	}
}
</code>
</pre>
<h4 class = "text-light">Constructor</h4>
<p>The constructor is a method with no return type (not void) and does not have the static keyword. Its purpose is to outline how the class will create an object, and similar to other methods, may have parameters to accept input. Without parameters, the constructor becomes a default constructor, which outlines the default object created from the class. 
</br></br>The updated code with a default constructor becomes:
</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public class Ball{
	public String color;
	public int size;
	public Ball(){
		color = "red"; //default color is red
		size = 1; //default size is 1
	}
	public Ball(String c, int s){
		color = c;
		size = s;
	}
	public String getColor(){
		return color;
	}
	public int getSize(){
		return size;
	}
	public void setColor(String c){
		color = c;
	}
	public void setSize(int s){
		size = s;
	}
	public void roll(){
		//code not shown
	}
}
</code>
</pre>
<h4 class = "text-light">Static Method</h4>
<p>The purpose of static methods is to allow certain methods to be run without the necessity of creating an object first. An example could be the Math utility class bundled within java. </br></br>
When we want to square root a number, we do not do:
</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
Math mathObject = new Math(); 
mathObject.sqrt(number); 
</code>
</pre>
<p>This is unnecessary because the object does not need to be there; a square root should work regardless of any variation in the object. Instead, we see the method being run directly from the class:</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
Math.sqrt(number);
</code>
</pre>
<p>In general, static methods are associated with the class, and instance methods are associated with the object.
</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public static double sqrt(double number){
	//code not shown
}
</code>
</pre>
<h4 class = "text-light">Instance Method</h4>
<p>An instance method is a regular method with no special properties. It simply follows the access level, return type, name, and parameter header. It requires an object to use.
</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public void roll(){
	//code not shown
}
</code>
</pre>
<h4 class = "text-light">Overloaded Methods</h4>
<p>Multiple methods with the same name but different parameter lists so that their method signature is different. This allows the compiler to tell which overloaded method is currently being used. For example, I can have both a default constructor, which will have no parameters, and a custom constructor, where each parameter represents an instance variable’s value. These two will have different method signatures due to the difference in parameters but will have the same name (class name). 
</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public void roll(){
	//code not shown
}
public void roll(int distance){
	//code not shown
}
</code>
</pre>
</div>
                        <div class="tab-pane fade" id="list-2" role="tabpanel">
						<h4 class = "text-light">Encapsulation</h4>
						
						<p>One of the major principles of OOP is to be able to control access of components of an object or class from separate areas of code. The major keywords that are used to control this are:</p>
						<div class="row">
						<div class="col-5 py-0">
							<h5 class = "text-light">public</h4>
							<p>Public allows the class / class component to be used within any client program.
However, an access level of public on a class does not mean that all the components within the class are public. Therefore, a client program may be able to use a class but not access specific methods or variables.
</p>
						</div>
						<div class="col-5 py-0">
							<h5 class = "text-light">private</h4>
							<p>Private prevents the class component from being used in any other location but the class itself. The private keyword can not be applied to a class, as that would prevent the usage of that class. This access level is generally applied to instance variables in a class, as mutators and accessors should undertake the role of changing and getting the value of an instance variable.
</p>
						</div>
						</div>
						<p>Learning this, we change the Ball class once again to ensure the instance variables have a private access level.</p>
						<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public class Ball{
	private String color;
	private int size;
	public Ball(){
		color = "red"; //default color is red
		size = 1; //default size is 1
	}
	public Ball(String c, int s){
		color = c;
		size = s;
	}
	public String getColor(){
		return color;
	}
	public int getSize(){
		return size;
	}
	public void setColor(String c){
		color = c;
	}
	public void setSize(int s){
		size = s;
	}
	public void roll(){
		//code not shown
	}
}
</code>
</pre>
						</div>
                        <div class="tab-pane fade" id="list-3" role="tabpanel">
							<h4 class = "text-light">Inheritance</h4>
							<p>Another key aspect of OOP is the ability to share properties and reuse code between classes. In general, subclasses, otherwise known as child classes, will inherit or reuse methods and variables from superclasses, otherwise known as parent classes, while usually adding some new methods and instance variables to expand the behaviour of the new class. The relationship between the child to the parent is known as a “is-a” relationship and the relationship between the parent to the child is known as a “has-a” relationship.
</p>		
							<div class="row">
						<div class="col-6 py-0">
							<h5 class = "text-light">BouncyBall.java</h4>
							<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public class BouncyBall extends Ball{
	private double bounciness;
	public BouncyBall(){
		bounciness = 0.1;
	}
	public String getBounciness(){
		return bounciness;
	}
	public void setBounciness(double b){
		bounciness = b;
	}
	public void bounce(){
		//code not shown
	}
}
</code>
</pre>
						</div>
						<div class="col-6 py-0">
							<h5 class = "text-light">Ball.java</h4>
							<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public class Ball{
	private String color;
	private int size;
	public Ball(){
		color = "red"; //default color is red
		size = 1 //default size is 1
	}
	public Ball(String c, int s){
		color = c;
		size = s;
	}
	public String getColor(){
		return color;
	}
	public int getSize(){
		return size;
	}
	public void setColor(String c){
		color = c;
	}
	public void setSize(int s){
		size = s;
	}
	public void roll(){
		//code not shown
	}
}
</code>
</pre>

						</div>
						</div>
						<p>In this situation, the BouncyBall class will be a subclass, and the Ball class will be a superclass. Notice that the BouncyBall class has an extra bit of code past the normal class header: extends Ball. This extends keyword is what expresses inheritance in Java. From this example, we can see the usefulness of inheritance. Instead of having to copy the entirety of the code from Ball into BouncyBall, we simply need to use the extends keyword and implement the extra functionality. In this case, we add the double bounciness, the void instance method bounce, and the mutator and accessor for bounciness. 
</p>
</br>
<p>There are some additional keywords that can be used to allow for additional functionality. The super keyword allows the class to use methods and constructors from the superclass. For example, to access the Ball constructor in the BouncyBall constructor, the code would look like this:
</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public BouncyBall(String c, int s, double b){
	super(c, s);
	bounciness = b;
}
</code>
</pre>

<p>We will talk about the use of super to overload methods in Polymorphism. 
</br></br>
Superclasses and Subclasses are also interconnected in a multitude of ways. A superclass variable, for example, can store objects of a subclass. In terms of our example, we could store a BouncyBall object in a Ball variable.
</p>
<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
Ball bouncy = new BouncyBall(“red”, 10, 0.1);
</code>
</pre>
<p>We will discuss the implications and uses of this in the next section, Polymorphism.</p>


						</div>
						<div class="tab-pane fade" id="list-4" role="tabpanel">
						<h4 class = "text-light">Polymorphism</h4>
						<p>Polymorphism comes from the greek prefix poly-, meaning many, and morphe, meaning form. This literally translates to many forms, which will make more sense as we go along. We begin with our example of BouncyBall and Ball. Say I want a regular ball to roll differently from a bouncy ball. However, I don’t want to go through the inconvenience of creating a completely separate method for it. Therefore, we decide to override the method roll in BouncyBall.</p>
						<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public void roll (){
	//code different but not shown
}
</code>
</pre>
<p>Now from the previous section on Methods we have learned about method overloading and how the compiler processes and determines which method to use. We recall that a method’s signature is how the compiler can tell the difference between each overload. Yet in this case, the method signatures are identical! So how will the compiler deduce which method to use? In short, it doesn’t need to. The method is tied to a specific class, and since they are still instance methods, require an object to run. The method is simply determined by the type of object that the method runs from.
</p>
						<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
Ball bouncy = new BouncyBall(“red”, 10, 0.1);
</code>
</pre>
<p>Even the bouncy object, which appears to be of type Ball, will still use the BouncyBall override for roll because the object is still inherently of type BouncyBall. 
</p>
</br>
<p>Continuing with the bouncy object, we see that the variable is of type Ball. This means that any methods that can only be run from a BouncyBall object, like bounce(), will return an error.</p>
												<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
bouncy.bounce(); //returns an error
</code>
</pre>
<p>Yet the object inherently stored in the variable is of type BouncyBall, and should be able to use the bounce() method. So what do we do? We introduce downcasting. Using casting we are able to turn the bouncy object back into a BouncyBall.
</p>
												<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
BouncyBall casted = (BouncyBall)bouncy;
</code>
</pre>
<p>This allows us to use the bounce method on casted.</p>
												<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
casted.bounce(); //no error
</code>
</pre>
<p>However, you must be careful that the underlying object stored within the superclass variable is the same type that you are casting to. For example, if we had another subclass from Ball, called BowlingBall, we would not be able to cast bouncy to a BowlingBall object.</p>
																		<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
BowlingBall casted = (BowlingBall)bouncy; //returns a ClassCastException
</code>
</pre>
						</div>
						<div class="tab-pane fade" id="list-5" role="tabpanel">
						<h4 class = "text-light">Abstraction</h4>
						<p>Another major paradigm of OOP is Abstraction. It hides the code implementation of certain methods from the user. This is accomplished in Java via the use of abstract classes and interfaces. </p>
						<div class="row">
						<div class="col-5 py-0">
							<h5 class = "text-light">Abstract Classes</h5>
							<p>Abstract classes are classes that are unable to be instantiated into objects, but can be inherited using the extend keyword. They may or may not contain abstract methods, which will be discussed below. These serve as a basic framework for shared code between classes that will likely be related and used in similar circumstances. </p>
						</div>
						<div class="col-5 py-0">
							<h5 class = "text-light">Abstract Method</h5>
							<p>An abstract method does not have any implementation or code. Instead, the subclasses that inherit the abstract class containing this method are expected to implement the method there. In fact, an error will occur when a class inherits an abstract class but does not implement all methods fully. </p>
						</div>
						</div>
						</br>
						<p>For example, let’s make the Ball class abstract, as we will only need BowlingBalls and BouncyBalls from now on (Assume BowlingBalls and BouncyBalls). BouncyBall and BowlingBall will likely share a lot of code; for example, they will still both roll. Therefore, we will likely keep roll as a shared method between the two classes. However, let’s add a method, play(), which will likely not have a shared implementation between BowlingBall and BouncyBall. Yet it is still a key feature and trait of every Ball. Therefore, let’s add the method play() and make it abstract.
</p>
						<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
public abstract class Ball{
	private String color;
	private int size;
	public Ball(){
		color = "red"; //default color is red
		size = 1 //default size is 1
	}
	public Ball(String c, int s){
		color = c;
		size = s;
	}
	public String getColor(){
		return color;
	}
	public int getSize(){
		return size;
	}
	public void setColor(String c){
		color = c;
	}
	public void setSize(int s){
		size = s;
	}
	public void roll(){
		//code not shown
	}
	public abstract void play();
}
</code>
</pre>
<h5 class = "text-light">Interfaces</h5>
<p>Interfaces are similar to abstract classes in that they are also used to simplify common functionality between classes. In this case, classes may not even need to be related in any other way. While an abstract class called Shape may have subclasses which are heavily related to each other (Triangle, Rectangle, Circle), an interface such as Comparable may be implemented by a large variety of classes, like ArrayLists, Strings, or the Integer wrapper class. In this way, interfaces will be different from abstract classes. They also use the keyword implements instead of extends, and can not have instance variables or methods that are not abstract or default. In other words, it is a purely abstract class, containing no additional shared methods or implementations. 
</p>
</br>
<p>For example, instead of using shared roll() code in the abstract class Ball, let’s make an interface known as Rollable. This may be implemented by a variety of classes, such as Pencil, RollingPin, and Barrel, which may have nothing to do with Balls. By creating this interface Rollable, we simply let Ball implement Rollable. This way, Ball can still have a common implementation for roll() for both BowlingBall and BouncyBall. </p>
						<pre class = "prettyprint lang-java bg-dark shadow-lg">
<code>
interface Rollable
{ 
    void roll(); 
} 
</code>
</pre>
						</div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <br></br>
      </div>
      <
      <!-- Optional JavaScript -->
      <!-- jQuery first, then Popper.js, then Bootstrap JS -->
      <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/15.2.1/smooth-scroll.js"></script>
      <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
      <script>
         $(function(){
         var scroll = new SmoothScroll('a[href *= "#s-"]');
         });
      </script>
   </body>
</html>